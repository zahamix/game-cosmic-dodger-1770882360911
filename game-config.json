{
  "gameName": "Cosmic Dodger",
  "version": "1.0.0",
  "htmlContent": "<!DOCTYPE html>\n<html>\n<!-- SETTINGS: {\n  \"colors\": {\n    \"player_color\": {\"label\": \"Player Color\", \"type\": \"color\", \"value\": \"#00d2ff\"},\n    \"enemy_color\": {\"label\": \"Enemy Color\", \"type\": \"color\", \"value\": \"#ff4757\"},\n    \"star_color\": {\"label\": \"Star Color\", \"type\": \"color\", \"value\": \"#ffffff\"}\n  },\n  \"numbers\": {\n    \"player_speed\": {\"label\": \"Player Speed\", \"type\": \"number\", \"value\": 1.5, \"min\": 0.5, \"max\": 3.0},\n    \"spawn_rate\": {\"label\": \"Spawn Rate (ms)\", \"type\": \"number\", \"value\": 1200, \"min\": 500, \"max\": 3000}\n  },\n  \"booleans\": {\n    \"enable_particles\": {\"label\": \"Enable Particles\", \"type\": \"boolean\", \"value\": true}\n  },\n  \"images\": {},\n  \"audio\": {},\n  \"select\": {},\n  \"assets\": {}\n} -->\n<!-- NAME: Cosmic Dodger -->\n<!-- EMOJI: ðŸš€ -->\n<!-- GRADIENT1: #0f2027 -->\n<!-- GRADIENT2: #2c5364 -->\n<!-- CATEGORY: Action -->\n<!-- DIFFICULTY: Medium -->\n<!-- Horizontal: false -->\n<!-- VERSION: 1.0 -->\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\">\n<title>Cosmic Dodger</title>\n<style>\n  :root {\n    --primary: #00d2ff;\n    --danger: #ff4757;\n    --bg-grad-1: #0f2027;\n    --bg-grad-2: #2c5364;\n    --font-main: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n  }\n  \n  * {\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-user-select: none;\n    -webkit-touch-callout: none;\n  }\n\n  body, html {\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: linear-gradient(135deg, var(--bg-grad-1), var(--bg-grad-2));\n    font-family: var(--font-main);\n    touch-action: none;\n  }\n\n  #gameCanvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    touch-action: none;\n  }\n\n  #uiLayer {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 10;\n    pointer-events: none;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .screen {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    background: rgba(0, 0, 0, 0.6);\n    backdrop-filter: blur(4px);\n    -webkit-backdrop-filter: blur(4px);\n    padding: 80px 20px; /* Safe zone clearance */\n    pointer-events: auto;\n    transition: opacity 0.3s ease;\n  }\n\n  h1 {\n    color: #fff;\n    font-size: 8vmin;\n    margin: 0 0 20px 0;\n    text-transform: uppercase;\n    letter-spacing: 2px;\n    text-shadow: 0 4px 10px rgba(0,0,0,0.5);\n    text-align: center;\n  }\n\n  p {\n    color: #eee;\n    font-size: 4vmin;\n    margin: 0 0 40px 0;\n    text-align: center;\n    max-width: 80%;\n    line-height: 1.5;\n  }\n\n  .score-display {\n    font-size: 12vmin;\n    font-weight: bold;\n    color: var(--primary);\n    margin-bottom: 20px;\n    text-shadow: 0 0 20px rgba(0, 210, 255, 0.5);\n  }\n\n  button {\n    background: var(--primary);\n    color: #000;\n    border: none;\n    padding: 15px 40px;\n    font-size: 5vmin;\n    font-weight: bold;\n    border-radius: 50px;\n    cursor: pointer;\n    box-shadow: 0 10px 20px rgba(0,0,0,0.3);\n    transition: transform 0.1s, background 0.2s;\n    min-width: 200px;\n    min-height: 60px;\n    touch-action: manipulation;\n  }\n\n  button:active {\n    transform: scale(0.95);\n    background: #fff;\n  }\n\n  #hud {\n    position: absolute;\n    top: max(20px, env(safe-area-inset-top));\n    left: 0;\n    width: 100%;\n    text-align: center;\n    pointer-events: none;\n    z-index: 20;\n    display: none;\n  }\n\n  #hudScore {\n    color: #fff;\n    font-size: 6vmin;\n    font-weight: bold;\n    text-shadow: 0 2px 4px rgba(0,0,0,0.5);\n  }\n\n  .hidden {\n    display: none !important;\n    opacity: 0;\n    pointer-events: none !important;\n  }\n</style>\n</head>\n<body>\n\n<canvas id=\"gameCanvas\"></canvas>\n\n<div id=\"uiLayer\">\n  <!-- HUD -->\n  <div id=\"hud\">\n    <div id=\"hudScore\">0</div>\n  </div>\n\n  <!-- MENU SCREEN -->\n  <div id=\"menuScreen\" class=\"screen\">\n    <h1>Cosmic<br>Dodger</h1>\n    <p>Drag to move.<br>Avoid the red asteroids.</p>\n    <button id=\"startBtn\">START MISSION</button>\n  </div>\n\n  <!-- GAME OVER SCREEN -->\n  <div id=\"gameoverScreen\" class=\"screen hidden\">\n    <h1>GAME OVER</h1>\n    <div class=\"score-display\" id=\"finalScore\">0</div>\n    <p>Best: <span id=\"bestScore\">0</span></p>\n    <button id=\"restartBtn\">TRY AGAIN</button>\n  </div>\n</div>\n\n<script>\n/**\n * ENGINE CONFIGURATION & CONSTANTS\n */\nconst CONFIG = {\n  colors: {\n    player: \"#00d2ff\",\n    enemy: \"#ff4757\",\n    star: \"#ffffff\"\n  },\n  playerSpeed: 1.5,\n  spawnRate: 1200,\n  enableParticles: true\n};\n\nconst STATE = {\n  BOOT: 0,\n  MENU: 1,\n  PLAYING: 2,\n  GAMEOVER: 3\n};\n\n/**\n * GLOBAL VARIABLES\n */\nlet canvas, ctx;\nlet currentState = STATE.BOOT;\nlet lastTime = 0;\nlet score = 0;\nlet highScore = 0;\nlet frameCount = 0;\n\n// Entities\nlet player = { x: 0, y: 0, width: 0, height: 0, color: CONFIG.colors.player };\nlet enemies = [];\nlet particles = [];\nlet stars = [];\nlet enemyTimer = 0;\n\n// Input\nlet input = {\n  active: false,\n  x: 0,\n  targetX: 0\n};\n\n// DOM Elements\nconst ui = {\n  menu: document.getElementById('menuScreen'),\n  gameover: document.getElementById('gameoverScreen'),\n  hud: document.getElementById('hud'),\n  hudScore: document.getElementById('hudScore'),\n  finalScore: document.getElementById('finalScore'),\n  bestScore: document.getElementById('bestScore'),\n  startBtn: document.getElementById('startBtn'),\n  restartBtn: document.getElementById('restartBtn')\n};\n\n/**\n * INITIALIZATION\n */\nfunction init() {\n  canvas = document.getElementById('gameCanvas');\n  ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base canvas\n\n  // Event Listeners\n  window.addEventListener('resize', resizeCanvas);\n  \n  // Button Listeners (Pointer Events)\n  ui.startBtn.addEventListener('pointerdown', (e) => {\n    e.preventDefault();\n    startGame();\n  });\n\n  ui.restartBtn.addEventListener('pointerdown', (e) => {\n    e.preventDefault();\n    startGame();\n  });\n\n  // Canvas Input Listeners\n  canvas.addEventListener('pointerdown', handleInputStart, { passive: false });\n  canvas.addEventListener('pointermove', handleInputMove, { passive: false });\n  canvas.addEventListener('pointerup', handleInputEnd, { passive: false });\n  canvas.addEventListener('pointercancel', handleInputEnd, { passive: false });\n\n  // Initial Setup\n  resizeCanvas();\n  createStars();\n  setState(STATE.MENU);\n  \n  // Start Loop\n  requestAnimationFrame(loop);\n}\n\nfunction resizeCanvas() {\n  const dpr = window.devicePixelRatio || 1;\n  canvas.width = window.innerWidth * dpr;\n  canvas.height = window.innerHeight * dpr;\n  ctx.scale(dpr, dpr);\n  \n  // Update player Y position based on new height\n  if (currentState !== STATE.PLAYING) {\n    resetPlayerPos();\n  }\n}\n\nfunction resetPlayerPos() {\n  const w = window.innerWidth;\n  const h = window.innerHeight;\n  player.width = w * 0.1; // 10% of screen width\n  player.height = player.width; // Square\n  player.x = w / 2 - player.width / 2;\n  player.y = h - player.height - Math.max(80, h * 0.15); // Safe zone buffer\n  input.targetX = player.x;\n}\n\nfunction createStars() {\n  stars = [];\n  const count = 50;\n  for (let i = 0; i < count; i++) {\n    stars.push({\n      x: Math.random() * window.innerWidth,\n      y: Math.random() * window.innerHeight,\n      size: Math.random() * 2 + 1,\n      speed: Math.random() * 0.5 + 0.1\n    });\n  }\n}\n\n/**\n * STATE MANAGEMENT\n */\nfunction setState(newState) {\n  currentState = newState;\n  \n  // Reset UI\n  ui.menu.classList.add('hidden');\n  ui.gameover.classList.add('hidden');\n  ui.hud.style.display = 'none';\n  canvas.style.pointerEvents = 'none'; // Default to no canvas input\n\n  switch (newState) {\n    case STATE.MENU:\n      ui.menu.classList.remove('hidden');\n      break;\n    case STATE.PLAYING:\n      ui.hud.style.display = 'block';\n      canvas.style.pointerEvents = 'auto'; // Enable game input\n      break;\n    case STATE.GAMEOVER:\n      ui.gameover.classList.remove('hidden');\n      ui.finalScore.textContent = score;\n      ui.bestScore.textContent = highScore;\n      break;\n  }\n}\n\nfunction startGame() {\n  score = 0;\n  ui.hudScore.textContent = \"0\";\n  enemies = [];\n  particles = [];\n  enemyTimer = 0;\n  resetPlayerPos();\n  input.active = false;\n  input.x = player.x + player.width/2;\n  setState(STATE.PLAYING);\n}\n\nfunction gameOver() {\n  if (score > highScore) highScore = score;\n  \n  // Explosion effect at player position\n  if (CONFIG.enableParticles) {\n    createExplosion(player.x + player.width/2, player.y + player.height/2, CONFIG.colors.player, 20);\n  }\n  \n  setState(STATE.GAMEOVER);\n}\n\n/**\n * INPUT HANDLING\n */\nfunction handleInputStart(e) {\n  if (currentState !== STATE.PLAYING) return;\n  e.preventDefault();\n  input.active = true;\n  input.x = e.clientX;\n}\n\nfunction handleInputMove(e) {\n  if (currentState !== STATE.PLAYING || !input.active) return;\n  e.preventDefault();\n  \n  const dx = e.clientX - input.x;\n  player.x += dx * CONFIG.playerSpeed;\n  \n  // Clamp player to screen\n  if (player.x < 0) player.x = 0;\n  if (player.x > window.innerWidth - player.width) player.x = window.innerWidth - player.width;\n  \n  input.x = e.clientX;\n}\n\nfunction handleInputEnd(e) {\n  input.active = false;\n}\n\n/**\n * GAME LOGIC\n */\nfunction spawnEnemy() {\n  const size = window.innerWidth * 0.08; // 8% screen width\n  const x = Math.random() * (window.innerWidth - size);\n  enemies.push({\n    x: x,\n    y: -size,\n    size: size,\n    speed: (window.innerHeight * 0.005) + (Math.random() * 2), // Base speed + random\n    color: CONFIG.colors.enemy\n  });\n}\n\nfunction createExplosion(x, y, color, count) {\n  for (let i = 0; i < count; i++) {\n    particles.push({\n      x: x,\n      y: y,\n      vx: (Math.random() - 0.5) * 10,\n      vy: (Math.random() - 0.5) * 10,\n      life: 1.0,\n      color: color,\n      size: Math.random() * 5 + 2\n    });\n  }\n}\n\nfunction update(dt) {\n  // Always update stars (background)\n  stars.forEach(star => {\n    star.y += star.speed * (dt / 16);\n    if (star.y > window.innerHeight) {\n      star.y = 0;\n      star.x = Math.random() * window.innerWidth;\n    }\n  });\n\n  if (currentState !== STATE.PLAYING) return;\n\n  // Spawn Enemies\n  enemyTimer += dt;\n  // Difficulty ramp: spawn faster as score increases\n  const currentSpawnRate = Math.max(200, CONFIG.spawnRate - (score * 10));\n  \n  if (enemyTimer > currentSpawnRate) {\n    spawnEnemy();\n    enemyTimer = 0;\n  }\n\n  // Update Enemies\n  for (let i = enemies.length - 1; i >= 0; i--) {\n    let e = enemies[i];\n    e.y += e.speed * (dt / 16);\n\n    // Collision Detection (Circle vs Rectangle)\n    // Simplified to Rectangle vs Rectangle for performance/robustness\n    if (\n      player.x < e.x + e.size &&\n      player.x + player.width > e.x &&\n      player.y < e.y + e.size &&\n      player.y + player.height > e.y\n    ) {\n      gameOver();\n      return;\n    }\n\n    // Remove if off screen\n    if (e.y > window.innerHeight) {\n      enemies.splice(i, 1);\n      score++;\n      ui.hudScore.textContent = score;\n    }\n  }\n\n  // Update Particles\n  if (CONFIG.enableParticles) {\n    for (let i = particles.length - 1; i >= 0; i--) {\n      let p = particles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= 0.02;\n      if (p.life <= 0) {\n        particles.splice(i, 1);\n      }\n    }\n  }\n}\n\n/**\n * RENDERING\n */\nfunction render() {\n  // Clear Canvas\n  ctx.fillStyle = \"#0f2027\"; // Match gradient start for base\n  ctx.fillRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);\n  \n  // Draw Background Gradient\n  const grad = ctx.createLinearGradient(0, 0, window.innerWidth, window.innerHeight);\n  grad.addColorStop(0, CONFIG.colors.star); // Actually using star color logic for bg slightly wrong, using CSS vars\n  // Re-creating gradient from metadata manually for canvas\n  const bgGrad = ctx.createLinearGradient(0, 0, 0, window.innerHeight);\n  bgGrad.addColorStop(0, \"#0f2027\");\n  bgGrad.addColorStop(1, \"#2c5364\");\n  ctx.fillStyle = bgGrad;\n  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);\n\n  // Draw Stars\n  ctx.fillStyle = CONFIG.colors.star;\n  stars.forEach(star => {\n    ctx.globalAlpha = Math.random() * 0.5 + 0.5;\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  ctx.globalAlpha = 1.0;\n\n  // Draw Player\n  if (currentState === STATE.PLAYING || currentState === STATE.MENU) {\n    ctx.fillStyle = player.color;\n    ctx.shadowBlur = 20;\n    ctx.shadowColor = player.color;\n    \n    // Draw Triangle Ship\n    ctx.beginPath();\n    ctx.moveTo(player.x + player.width / 2, player.y);\n    ctx.lineTo(player.x + player.width, player.y + player.height);\n    ctx.lineTo(player.x, player.y + player.height);\n    ctx.closePath();\n    ctx.fill();\n    \n    ctx.shadowBlur = 0;\n  }\n\n  // Draw Enemies\n  ctx.fillStyle = CONFIG.colors.enemy;\n  enemies.forEach(e => {\n    ctx.beginPath();\n    ctx.arc(e.x + e.size/2, e.y + e.size/2, e.size/2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Simple shading\n    ctx.fillStyle = \"rgba(255,255,255,0.2)\";\n    ctx.beginPath();\n    ctx.arc(e.x + e.size/3, e.y + e.size/3, e.size/6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = CONFIG.colors.enemy;\n  });\n\n  // Draw Particles\n  particles.forEach(p => {\n    ctx.fillStyle = p.color;\n    ctx.globalAlpha = p.life;\n    ctx.fillRect(p.x, p.y, p.size, p.size);\n  });\n  ctx.globalAlpha = 1.0;\n}\n\n/**\n * MAIN LOOP\n */\nfunction loop(timestamp) {\n  const dt = timestamp - lastTime;\n  lastTime = timestamp;\n\n  update(dt);\n  render();\n\n  requestAnimationFrame(loop);\n}\n\n// Start everything\ninit();\n\n</script>\n</body>\n</html>"
}